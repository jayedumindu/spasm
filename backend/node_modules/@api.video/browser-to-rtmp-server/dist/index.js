"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const crypto_1 = require("crypto");
const events_1 = __importDefault(require("events"));
const socket_io_1 = require("socket.io");
const tslog_1 = require("tslog");
const connection_1 = __importDefault(require("./connection"));
const ts_deepmerge_1 = __importDefault(require("ts-deepmerge"));
const DEFAULT_OPTIONS = {
    serverLogs: {
        minLevel: 'info'
    },
    clientLogs: {
        sendErrorDetails: false,
        sendFfmpegOutput: false
    }
};
class BrowserToRtmpServer extends events_1.default {
    constructor(server, opts) {
        super();
        this.connections = new Map();
        this.opts = (0, ts_deepmerge_1.default)(DEFAULT_OPTIONS, opts || {});
        this.logger = new tslog_1.Logger({
            minLevel: this.opts.serverLogs?.minLevel || 'info',
        });
        this.io = new socket_io_1.Server(server, this.opts.socketio);
        this.io.on('connection', (socket) => this.onConnection(socket));
    }
    getConnections() {
        return [...this.connections.values()].map(a => a.getStatus());
    }
    getConnection(id) {
        return this.connections.get(id)?.getStatus();
    }
    countFfmpegInstances() {
        return [...this.connections.values()].filter(c => !!c.getStatus().ffmpeg).length;
    }
    onConnection(socket) {
        const connectionId = (0, crypto_1.randomUUID)();
        const connection = new connection_1.default(this.logger, socket, connectionId, (s, event) => {
            if (typeof this.opts.maxFfmpegInstances !== "undefined" && this.countFfmpegInstances() >= this.opts.maxFfmpegInstances) {
                throw new Error("Max ffmpeg instances reached");
            }
            if (this.opts?.hooks?.start) {
                event = this.opts.hooks.start(s, event);
            }
            if (event.rtmp && this.opts.rtmpUrlRegexp && !this.opts.rtmpUrlRegexp?.test(event.rtmp)) {
                throw new Error("The RTMP url doesn't match the rtmpUrlRegexp");
            }
            return event;
        });
        this.connections.set(connectionId, connection);
        this.emit('connection', connection.getStatus());
        connection.on('error', (e) => {
            if (!this.opts.clientLogs?.sendErrorDetails) {
                socket.emit('error', {
                    ...e,
                    details: undefined,
                    message: ""
                });
            }
            else {
                socket.emit('error', e);
            }
            this.emit('error', connectionId, e);
        });
        connection.on('ffmpegOutput', (e) => {
            if (this.opts.clientLogs?.sendFfmpegOutput) {
                socket.emit('ffmpegOutput', e);
            }
            this.emit('ffmpegOutput', connectionId, e);
        });
        connection.on('destroyed', () => {
            this.emit('destroyed', connectionId);
        });
        socket.on('disconnect', () => {
            connection.destroy();
            this.connections.delete(connectionId);
        });
    }
}
module.exports = BrowserToRtmpServer;
//# sourceMappingURL=index.js.map